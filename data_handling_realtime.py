import pandas as pd
from datetime import datetime
import time

# log_file_reading_interval = 1       # File reading interval (sec)

# +------------------------------------------------------------------+
# FILE TRANSMIT PATHS
# +------------------------------------------------------------------+

mt5_account_number = 828    # LAST 3 DIGITS OF MT5 ACCOUNT. MUST BE CHANGED BEFORE BUILDING EXE

# MT5 directory with OHLC log file (logging on active timeframe):

# ------------------------
# LIIKURI PATHS # HASH FOLDER MUST BE CHANGED BEFORE EXE BUILD
# mt5_logging_file_path = (
#     f'C:\\Users\\Liikurserv\\AppData\\Roaming\\MetaQuotes\\Terminal\\09FF355D73768D9CE6BDD4EE575EAB09\\MQL5\\Files\\'
#     f'OHLCVData_{mt5_account_number}.csv'
# )

# OHLC saved by NT8
nt8_logging_file_path = f'C:\\Users\\Liikurserv\\PycharmProjects\\RT_Ninja\\OHLCVData_1.csv'

# File with signal generated by Python script
nt8_buy_sell_signals_for_path = (
     f'C:\\Users\\Liikurserv\\PycharmProjects\\RT_Ninja\\trade_signal.txt'
     )

# Levels PATH for NinjaTrader:
# levels_path = (
#     f'C:\\Users\\Liikurserv\\PycharmProjects\\RT_Ninja\\hardcoded_sr_levels.csv'
# )

list_of_orders_path = 'C:\\Users\\Liikurserv\\PycharmProjects\\RT_Ninja\\list_of_orders.csv'

position_state_longs_path = 'position_state_longs.txt'
position_state_shorts_path = 'position_state_shorts.txt'

current_order_direction_path = 'C:\\Users\\Liikurserv\\PycharmProjects\\RT_Ninja\\current_order_direction.txt'

current_time = datetime.now().strftime('%Y-%m-%d %H:%M:%S')


def leave_only_last_line():     # Clear file before starting the script
    with open(nt8_logging_file_path, 'r', encoding='utf-8') as file:
        lines = file.readlines()
        # Check if there's at least one line to keep
        if lines:
            with open(nt8_logging_file_path, 'w', encoding='utf-8') as file:
                file.write(lines[-1])  # Write only last several lines back to file
        else:
            print('Reading OHLC. File is empty...')


def get_dataframe_from_file(max_time_waiting_for_entry):

    log_df = pd.read_csv(
        nt8_logging_file_path,
        sep=';',
        encoding='utf-8',
        engine='python'
    )
    new_column_names = ['Ticker', 'Timeframe', 'Date', 'Time', 'Open', 'High', 'Low', 'Close', 'Volume']
    log_df.columns = new_column_names
    log_df['Datetime'] = pd.to_datetime(log_df['Date'] + ' ' + log_df['Time'], format='ISO8601')
    log_df.set_index('Datetime', inplace=True)
    dataframe_from_log = log_df.loc[:, ['Ticker', 'Date', 'Time', 'Open', 'High', 'Low', 'Close']]
    datetime_index = log_df.index
    last_date = str(datetime_index[-1])     # Get datetime of the first row of dataframe to pass along with levels

    return dataframe_from_log, last_date


def get_levels_from_file(last_datetime_of_df, valid_levels_path):
    updated_lines = []
    levels = []

    with open(valid_levels_path, 'r', encoding='utf-8') as file:
        for line in file:
            parts = line.strip().split(',')

            if len(parts) == 2:
                # Properly formatted line
                # line_key = parts[0].strip()
                timestamp = parts[0].strip()
                level = float(parts[1].strip())

            else:
                # line_key = parts[0].strip()
                timestamp = last_datetime_of_df
                level = float(parts[0].strip())

            # Add the formatted line to the update list
            updated_lines.append(f"{timestamp}, {level}\n")
            levels.append((timestamp, level))

    # Rewrite the file with only properly formatted lines
    with open(valid_levels_path, 'w', encoding='utf-8') as file:
        file.writelines(updated_lines)

    return levels


#   Remove level which has reached time threshold from file
def remove_expired_levels(level_lifetime_minutes, dataframe_from_log, interacted_levels, valid_levels_path, expired_levels_path):
    curr_time = dataframe_from_log.index[-1]  # Timestamp of the last line of dataframe
    updated_levels = []
    expired_levels = []
    print('\nLevels management:')
    print('interacted_levels', interacted_levels)
    print(f'level_lifetime_minutes: {level_lifetime_minutes} minutes\n')
    with open(valid_levels_path, 'r', encoding='utf-8') as file:
        for line in file:
            timestamp_str, file_level = line.strip().split(',')  # Get timestamp and level from file
            file_level = float(file_level.strip())

            # Flag to check if the level is still valid
            level_still_valid = False

            for interaction_time, level in interacted_levels:
                if level == file_level:  # Match the file level with interacted level
                    # Calculate the time difference
                    time_diff = (curr_time - pd.to_datetime(interaction_time)).total_seconds() / 60  # Convert to minutes
                    print(f"Level {level}: Time difference {time_diff:.2f} minutes")

                    if time_diff < level_lifetime_minutes:
                        level_still_valid = True  # Mark as valid
                        break  # No need to check other interactions for the same level

            # Add the level back if it’s still valid or hasn’t been interacted with
            if level_still_valid or all(file_level != lvl for _, lvl in interacted_levels):
                updated_levels.append(line)
            else:
                print(f"Removing expired level: {timestamp_str}, {file_level}")
                expired_levels.append(line)
                with open(expired_levels_path, 'a', encoding='utf-8') as file:
                    file.writelines(expired_levels)

    # Write the remaining levels back to the file
    with open(valid_levels_path, 'w', encoding='utf-8') as file:
        file.writelines(updated_levels)


# Function to read levels from NT8 chart levels
def read_chart_levels(file_path):
    levels = set()
    with open(file_path, 'r') as file:
        for line in file:
            # Extract price after the comma
            try:
                price = float(line.split(',')[-1].strip())
                levels.add(price)
            except ValueError:
                print(f"Invalid line in chart levels file: {line}")
    return levels


# Function to read prices from valid levels and expired levels
def read_price_levels(file_path):
    levels = set()
    with open(file_path, 'r') as file:
        for line in file:
            # Extract price after the comma
            try:
                price = float(line.split(',')[1].strip())
                levels.add(price)
            except (IndexError, ValueError):
                print(f"Invalid line in file: {line}")
    return levels


# Function to append new levels to the valid levels file
def append_new_levels(file_path, new_levels):
    with open(file_path, 'a') as file:
        for level in new_levels:
            file.write(f"{level}\n")


# Tracks if there is an open position
def get_position_state_shorts():
    with open(position_state_shorts_path, 'r', encoding='utf-8') as file:
        state = file.read()
        return state


def get_position_state_longs():
    with open(position_state_longs_path, 'r', encoding='utf-8') as file:
        state = file.read()
        return state


def get_current_pending_order_direction():
    with open(current_order_direction_path, 'r', encoding='utf-8') as file:
        current_pending_order = file.read().strip()
        return current_pending_order


def save_order_parameters_to_file(line_order_parameters):   # Called from orders_sender.py
    retries = 5
    for attempt in range(retries):
        try:
            with open(nt8_buy_sell_signals_for_path, 'w', encoding='utf-8') as file:
                file.writelines(line_order_parameters)
                print(f"NEW ORDER IS SUCCESSFULLY SAVED TO FILE")
            break
        except PermissionError:
            print(f"Attempt {attempt + 1} failed. Retrying...")
            time.sleep(1)
    else:
        print("Failed to write to the file after multiple attempts.")


# Create orders list file to track orders
def save_list_of_orders_to_file(line_order_parameters_to_order_list):
    with open(list_of_orders_path, 'w', encoding='utf-8') as file:
        file.writelines(line_order_parameters_to_order_list)


def get_last_order_time_from_file():
    with open(list_of_orders_path, 'r', encoding='utf-8') as file:
        last_order_timestamp = pd.to_datetime(file.read())
        if pd.isna(last_order_timestamp):
            last_order_timestamp = pd.to_datetime('2024-01-01 00:00:00')  # Default value while the file is empty

        return last_order_timestamp
